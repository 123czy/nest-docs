import{_ as s,c as p,o as t,V as e}from"./chunks/framework.BbAbY5cn.js";const r="/assets/第51章-1.L7K1rzas.png",o="/assets/第51章-2.1LPgi9x9.png",i="/assets/第51章-3.4bbNiGyE.png",a="/assets/第51章-4.1IUqJ8mx.png",n="/assets/第51章-5.Hl8uDCBM.png",c="/assets/第51章-6._Rn2RRvj.png",g="/assets/第51章-7.1lrpesuI.png",m="/assets/第51章-8.H3Ew-dbl.png",_="/assets/第51章-9.C7-DnHhT.png",d="/assets/第51章-10.KBywO0S-.png",l="/assets/第51章-11.nwwBtUZa.png",h="/assets/第51章-12.zv4YhZ2k.png",u="/assets/第51章-13.ReM7_waG.png",y="/assets/第51章-14.gQsUK0UQ.png",k="/assets/第51章-15.nJVO5DmO.png",f="/assets/第51章-16.5a6Zhw1x.png",q="/assets/第51章-17.U7TpY5Ny.png",x="/assets/第51章-18.IRtIWsCL.png",b="/assets/第51章-19.oCwfxIqX.png",z="/assets/第51章-20.6xFJbkes.png",I="/assets/第51章-21.uuWbcpsv.png",R="/assets/第51章-22.zwmBkPMJ.png",w="/assets/第51章-23.BoysSP3B.png",T="/assets/第51章-24.REmhAR3n.png",B="/assets/第51章-25.L3PyDsBQ.png",H="/assets/第51章-26.x-Parx-9.png",v="/assets/第51章-27.wZVmmHWb.png",G="/assets/第51章-28.0uRonj5K.png",P="/assets/第51章-29.KGsuBNgT.png",S="/assets/第51章-30.uCfLqfuv.png",U="/assets/第51章-31.8GS7lcTN.png",V="/assets/第51章-32.OX-M8Orr.png",C="/assets/第51章-33.LqgS5AqA.png",J="/assets/第51章-34.sQHM4r9Y.png",Q="/assets/第51章-35.cqJiGc7U.png",Z="/assets/第51章-36.owCOzxR2.png",A="/assets/第51章-37.nqgIxK9H.png",K="/assets/第51章-38.rrsfWwxE.png",M="/assets/第51章-39.T7WijZYV.png",N="/assets/第51章-40.3IElHRSN.png",D="/assets/第51章-41.bVndHQeK.png",E="/assets/第51章-42.ZKeeoo-c.png",L="/assets/第51章-43.HsJmS2Xn.png",O="/assets/第51章-44.RroGyqs8.png",Y="/assets/第51章-45.o8VQHm4I.png",j="/assets/第51章-46.DVr6wdwJ.png",W="/assets/第51章-47.tnXMZyjZ.png",X="/assets/第51章-48.N8B7KYJy.png",$="/assets/第51章-49.gitEZr91.png",F="/assets/第51章-50.8vAM02ga.png",ss="/assets/第51章-51.X_QTH7oF.png",ps="/assets/第51章-52.CqQHYQ6w.png",ts="/assets/第51章-53.I6fB4aAC.png",es="/assets/第51章-54.f0kMa6jv.png",rs="/assets/第51章-55.lorhbIoT.png",os="/assets/第51章-56.2QbVJLx6.png",is="/assets/第51章-57.MPZoAD5g.png",ks=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"第51章—快速入门Redis.md","filePath":"第51章—快速入门Redis.md"}'),as={name:"第51章—快速入门Redis.md"},ns=e('<p>前面我们学了 mysql，它是通过表和字段来存储信息的，表和表之间通过 id 关联，叫做关系型数据库。</p><p>它提供了 sql 语言，可以通过这种语言来描述对数据的增删改查。</p><p>mysql 是通过硬盘来存储信息的，并且还要解析并执行 sql 语句，这些决定了它会成为性能瓶颈。</p><p>也就是说服务端执行计算会很快，但是等待数据库查询结果就很慢了。</p><p>那怎么办呢？</p><p>计算机领域最经常考虑到的性能优化手段就是缓存了。</p><p>能不能把结果缓存在内存中，下次只查内存就好了呢？</p><p>内存和硬盘的速度差距还是很大的：</p><p><img src="'+r+'" alt=""></p><p>所以做后端服务的时候，我们不会只用 mysql，一般会结合内存数据库来做缓存，最常用的是 redis。</p><p>因为需求就是缓存不同类型的数据，所以 redis 的设计是 key、value 的键值对的形式。</p><p>并且值的类型有很多：字符串（string）、列表（list）、集合（set）、有序集合（sorted set)、哈希表（hash）、地理信息（geospatial）、位图（bitmap）等。</p><p>我们分别来试一下。</p><p>redis 是分为服务端和客户端的，它提供了一个 redis-cli 的命令行客户端。</p><p>首先我们把 redis 服务跑起来。</p><p>在 docker desktop 搜索框搜索 redis，点击 run，把 redis 官方镜像下载并跑起来。</p><p><img src="'+o+'" alt=""></p><p>它会让你填一些容器的信息：</p><p><img src="'+i+'" alt=""></p><p>端口映射就是把主机的 6379 端口映射到容器内的 6379 端口，这样就能直接通过本机端口访问容器内的服务了。</p><p>指定数据卷，用本机的任意一个目录挂载到容器内的 /data 目录，这样数据就会保存在本机。</p><p>跑起来之后是这样的：</p><p><img src="'+a+'" alt=""></p><p>容器内打印的日志说明 redis 服务跑起来了。</p><p>files 里可以看到所有的容器内的文件：</p><p><img src="'+n+'" alt=""></p><p>看到这个 mounted 的标志了没？</p><p>就代表这个目录是挂载的本地的一个目录。</p><p>我们在本地目录添加一个文件。</p><p><img src="'+c+'" alt=""></p><p>在容器内的 data 目录就能访问到这个文件了：</p><p><img src="'+g+'" alt=""></p><p>同样，在容器内修改了 data 目录，那本机目录下也会修改。</p><p>redis 服务跑起来之后，我们用 redis-cli 操作下。</p><p><img src="'+m+'" alt=""></p><p>在 terminal 输入 redis-cli，进入交互模式：</p><p><img src="'+_+'" alt=""></p><p>我们在这里做下 string 相关的操作：</p><p><a href="https://redis.io/docs/data-types/strings/" target="_blank" rel="noreferrer">文档</a>里的命令有这么几个：</p><p><img src="'+d+'" alt=""></p><p>set、get 都挺简单：</p><p><img src="'+l+'" alt=""></p><p>incr 是用于递增的：</p><p><img src="'+h+'" alt=""></p><p>平时我们用的阅读量、点赞量等都是通过这个来计数的。</p><p>当我存了几个 key 后，可以通过 keys 来查询有哪些 key:</p><p><img src="'+u+'" alt=""></p><p>keys 后加一个模式串来过滤，常用的是 &#39;*&#39; 来查询所有 key。</p><p>然后再来看看 list。</p><p>这里我们切换成 GUI 工具吧，那个更直观一些。</p><p>这个就像 git 有人喜欢用命令行，有人喜欢用 GUI 工具一样。只是习惯问题，都可以。</p><p>我用的是官方的 <a href="https://redis.com/redis-enterprise/redis-insight/#insight-form" target="_blank" rel="noreferrer">RedisInsight</a>，它号称是最好的 Redis GUI 工具：</p><p><img src="'+y+'" alt=""></p><p>输入操作系统信息，还有邮箱、姓名、职业、手机号等信息，就可以下载安装包了。</p><p><img src="'+k+'" alt=""></p><p>安装后就是这个东西：</p><p><img src="'+f+'" alt=""></p><p>点击 add database：</p><p><img src="'+q+'" alt=""></p><p>连接信息用默认的就行：</p><p><img src="'+x+'" alt=""></p><p>然后就可以看到新建的这个链接：</p><p><img src="'+b+'" alt=""></p><p>点击它就可以可视化看到所有的 key 和值：</p><p><img src="'+z+'" alt=""></p><p>同样也可以执行命令：</p><p><img src="'+I+'" alt=""></p><p>然后我们继续看 list 类型的数据结构：</p><p>文档中有这么几个命令：</p><p><img src="'+R+`" alt=""></p><p>我们试一下：</p><pre><code>lpush list1 111
lpush list1 222
lpush list1 333
</code></pre><p>输入上面的命令，点击执行：</p><p><img src="`+w+'" alt=""></p><p>然后回到浏览页面，点击刷新，就可以看到新的 key 和它的值：</p><p><img src="'+T+'" alt=""></p><p>这就是一个列表的结构。</p><p>lpush 是 left push 的意思，执行后会从左到右添加到列表中。</p><p><img src="'+B+`" alt=""></p><p>rpush 是 right push 的意思，执行后会从右往左添加到列表中：</p><pre><code>rpush list1 444
rpush list1 555
</code></pre><p><img src="`+H+'" alt=""></p><p><img src="'+v+'" alt=""></p><p><img src="'+G+`" alt=""></p><p>lpop 和 rpop 自然是从左边和从右边删除数据。</p><pre><code>lpop list1
</code></pre><p><img src="`+P+'" alt=""></p><p><img src="'+S+`" alt=""></p><pre><code>rpop list1
</code></pre><p><img src="`+U+'" alt=""></p><p><img src="'+V+'" alt=""></p><p><img src="'+C+`" alt=""></p><p>如果想查看 list 数据呢？</p><p>在 GUI 里直接点开看就行，但在命令行里呢？</p><p>有同学说，不就是 get 么？</p><p>是不行的，get 只适用于 string 类型的数据，list 类型的数据要用 lrange。</p><pre><code>lrange list1 0 -1
</code></pre><p><img src="`+J+'" alt=""></p><p>输入一段 range，结尾下标为 -1 代表到最后。lrange list1 0 -1 就是查询 list1 的全部数据。</p><p>接下来我们再来看看 set：</p><p><img src="'+Q+`" alt=""></p><p>set 的特点是无序并且元素不重复。</p><p>当我添加重复数据的时候：</p><pre><code>sadd set1 111
sadd set1 111
sadd set1 111
sadd set1 222
sadd set1 222
sadd set1 333
</code></pre><p><img src="`+Z+'" alt=""></p><p>刷新之后可以看到它只保留去重后的数据：</p><p><img src="'+A+`" alt=""></p><p>可以通过 sismember 判断是否是集合中的元素：</p><pre><code>sismember set1 111
</code></pre><p><img src="`+K+`" alt=""></p><pre><code>sismember set1 444
</code></pre><p><img src="`+M+'" alt=""></p><p>set 只能去重、判断包含，不能对元素排序。</p><p>如果排序、去重的需求，比如排行榜，可以用 sorted set，也就是 zset，：</p><p><img src="'+N+`" alt=""></p><p>它每个元素是有一个分数的：</p><pre><code>zadd zset1 5 guang
zadd zset1 4 dong
zadd zset1 3 xxx
zadd zset1 6 yyyy
</code></pre><p><img src="`+D+'" alt=""></p><p>会按照分数来排序：</p><p><img src="'+E+`" alt=""></p><p>通过 zrange 命令取数据，比如取排名前三的数据：</p><pre><code>zrange zset1 0 2
</code></pre><p><img src="`+L+'" alt=""></p><p>接下来是 hash：</p><p><img src="'+O+`" alt=""></p><p>和我们用的 map 一样，比较容易理解：</p><pre><code>hset hash1 key1 1
hset hash1 key2 2
hset hash1 key3 3
hset hash1 key4 4
hset hash1 key5 5
</code></pre><p><img src="`+Y+'" alt=""></p><p><img src="'+j+`" alt=""></p><pre><code>hget hash1 key3
</code></pre><p><img src="`+W+`" alt=""></p><p>再就是 geo 的数据结构，就是经纬度信息，根据距离计算周围的人用的。</p><p>我们试一下：</p><pre><code>geoadd loc 13.361389 38.115556 &quot;guangguang&quot; 15.087269 37.502669 &quot;dongdong&quot; 
</code></pre><p>用 loc 作为 key，分别添加 guangguang 和 dongdong 的经纬度</p><p><img src="`+X+'" alt=""></p><p>你会发现 redis 实际使用 zset 存储的，把经纬度转化为了二维平面的坐标：</p><p><img src="'+$+`" alt=""></p><p>你可以用 geodist 计算两个坐标点的距离：</p><pre><code>geodist loc guangguang dogndong
</code></pre><p><img src="`+F+`" alt=""></p><p>用 georadius 搜索某个半径内的其他点，传入经纬度、半径和单位：</p><pre><code>georadius loc 15 37 100 km
georadius loc 15 37 200 km
</code></pre><p><img src="`+ss+`" alt=""></p><p>平时我们查找周围的人、周围的 xxx 都可以通过 redis 的 geo 数据结构实现。</p><p>一般 redis 的 key 我们会设置过期时间，通过 expire 命令。</p><p>比如我设置 dong1 的 key 为 30 秒过期：</p><pre><code>expire dogn1 30
</code></pre><p><img src="`+ps+'" alt=""></p><p>等到了过期时间就会自动删除：</p><p><img src="'+ts+'" alt=""></p><p>想查剩余过期时间使用 ttl：</p><p><img src="'+es+'" alt=""></p><p>一些有时效的数据可以设置个过期时间。</p><p>redis 的数据结构就先介绍到这里。</p><p>所有的命令都可以在官方文档查： <a href="https://redis.io/commands/" target="_blank" rel="noreferrer">https://redis.io/commands/</a></p><p>是不是感觉还挺简单的。</p><p>确实，redis 学习成本挺低的，过一遍就会了。</p><p>回到最开始的问题，我们完全可以查出数据来之后放到 redis 中缓存，下次如果 redis 有数据就直接用，没有的话就查数据库然后更新 redis 缓存。</p><p>这是 redis 的第一种用途，作为数据库的缓存，也是主要的用途。</p><p>第二种用途就是直接作为存储数据的地方了，因为 redis 本身是会做持久化的，也可以把数据直接保存在 redis 里，不存到 mysql。</p><p>当然，因为 redis 在内存存储数据，这样成本还是比较高的，需要经常扩容。</p><p>最后，还记得我们跑 redis 的 docker 镜像时指定了数据卷么：</p><p><img src="'+rs+'" alt=""></p><p>可以看到它确实把数据保存到了宿主机，这样就不怕再跑一个容器数据会丢了：</p><p><img src="'+os+'" alt=""></p><p><img src="'+is+'" alt=""></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>这节我们学习了 redis。</p><p>因为 mysql 存在硬盘，并且会执行 sql 的解析，会成为系统的性能瓶颈，所以我们要做一些优化。</p><p>常见的就是在内存中缓存数据，使用 redis 这种内存数据库。</p><p>它是 key、value 的格式存储的，value 有很多种类型，比如 string、list、set、sorted set(zset)、hash、geo 等。</p><p>灵活运用这些数据结构，可以完成各种需求，比如排行榜用 zset、阅读数点赞数用 string、附近的人用 geo 等。</p><p>而且这些 key 都可以设置过期时间，可以完成一些时效性相关的业务。</p><p>用官方 GUI 工具 RedisInsight 可以可视化的操作它，很方便。</p><p>redis 几乎和 mysql 一样是后端系统的必用中间件了，它除了用来做数据库的缓存外，还可以直接作为数据存储的地方。</p><p>学会灵活使用 redis，是后端开发很重要的一步。</p>',177),cs=[ns];function gs(ms,_s,ds,ls,hs,us){return t(),p("div",null,cs)}const fs=s(as,[["render",gs]]);export{ks as __pageData,fs as default};
