import{_ as s,c as i,o as p,V as a}from"./chunks/framework.BbAbY5cn.js";const n="/assets/第08章-1.vFtrPPg4.png",t="/assets/第08章-2.clCaaIfC.png",l="/assets/第08章-3.OPGbrJ5W.png",e="/assets/第08章-4.sw4TZS-v.png",o="/assets/第08章-5.5NTzbJgO.png",h="/assets/第08章-6.2cUpCsk-.png",r="/assets/第08章-7.DIK7Jxmk.png",k="/assets/第08章-8.uKFF02hp.png",c="/assets/第08章-9.IDKitSCV.png",d="/assets/第08章-10.QQTYY9sa.png",E="/assets/第08章-11.M-r2XKPL.png",g="/assets/第08章-12.Usk9BIXn.png",y="/assets/第08章-13.Zdf1nJBo.png",m="/assets/第08章-14.PueNceE0.png",u="/assets/第08章-15.2UFEcLuY.png",_="/assets/第08章-16.CSo1iQkg.png",F="/assets/第08章-17.OWDE9VFm.png",C="/assets/第08章-18.rl8MnAYj.png",B="/assets/第08章-19.OOkNgjxu.png",v="/assets/第08章-20.IA4lIeHV.png",A="/assets/第08章-21.QU0xlcwv.png",M="/assets/第08章-22.e2B0_7jZ.png",f="/assets/第08章-23.lWjQKED9.png",b="/assets/第08章-24.hTye8SEi.png",S="/assets/第08章-25.NsdchP6j.png",D="/assets/第08章-26.efrNkPWH.png",w="/assets/第08章-27.E014Qhrr.png",I="/assets/第08章-28.JnnYwsVF.png",O="/assets/第08章-29.cL7j-mIH.png",P="/assets/第08章-30.U2AdLfqo.png",Y=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"第08章—全局模块和生命周期.md","filePath":"第08章—全局模块和生命周期.md"}'),j={name:"第08章—全局模块和生命周期.md"},N=a(`<p>模块导出 provider，另一个模块需要 imports 它才能用这些 provider。</p><p>但如果这个模块被很多模块依赖了，那每次都要 imports 就很麻烦。</p><p>能不能设置成全局的，它导出的 provider 直接可用呢？</p><p>Module、Controller、Provider 是由 Nest 创建的，能不能在创建、销毁的时候执行一些逻辑呢？</p><p>这节我们来学习下全局模块和生命周期。</p><p>创建一个 nest 项目：</p><pre><code>nest new global-and-lifecycle -p npm
</code></pre><p><img src="`+n+`" alt=""></p><p>然后创建两个 CRUD 的模块：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>nest g resource aaa --no-spec</span></span>
<span class="line"><span>nest g resource bbb --no-spec</span></span></code></pre></div><p>--no-spec 是不生成测试文件</p><p><img src="`+t+'" alt=""></p><p>在 AaaModule 里指定 exports 的 provider：</p><p><img src="'+l+'" alt=""></p><p>然后在 BbbModule 里 imports：</p><p><img src="'+e+'" alt=""></p><p>这样就可以在 BbbModule 内注入 AaaService 了：</p><p><img src="'+o+'" alt=""></p><p>把 nest 服务跑起来：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>npm run start:dev</span></span></code></pre></div><p>可以看到 aaaService 生效了：</p><p><img src="'+h+'" alt=""></p><p>这是我们常用的引入 Module 的方式。</p><p>但如果这个 AaaModule 被很多地方引用呢？</p><p>每个模块都 imports 太麻烦了，这时候就可以把它声明为全局的：</p><p><img src="'+r+'" alt=""></p><p>在 AaaModule 上加一个 @Global 的装饰器，然后在 BbbModule 里把 AaaModule 的 imports 去掉。</p><p><img src="'+k+'" alt=""></p><p>这样依然是可以注入的：</p><p><img src="'+c+'" alt=""></p><p><img src="'+d+'" alt=""></p><p>这就是全局模块。</p><p>不过全局模块还是尽量少用，不然注入的很多 provider 都不知道来源，会降低代码的可维护性。</p><p>然后是生命周期：</p><p>Nest 在启动的时候，会递归解析 Module 依赖，扫描其中的 provider、controller，注入它的依赖。</p><p>全部解析完后，会监听网络端口，开始处理请求。</p><p>这个过程中，Nest 暴露了一些生命周期方法：</p><p><img src="'+E+`" alt=""></p><p>首先，递归初始化模块，会依次调用模块内的 controller、provider 的 onModuleInit 方法，然后再调用 module 的 onModuleInit 方法。</p><p>全部初始化完之后，再依次调用模块内的 controller、provider 的 onApplicationBootstrap 方法，然后调用 module 的 onApplicationBootstrap 方法</p><p>然后监听网络端口。</p><p>之后 Nest 应用就正常运行了。</p><p>这个过程中，onModuleInit、onApplicationBootstrap 都是我们可以实现的生命周期方法。</p><p>我们来试一下：</p><p>再创建两个 Module：</p><pre><code>nest g resource ccc --no-spec
nest g resource ddd --no-spec
</code></pre><p><img src="`+g+'" alt=""></p><p>nest 提供了这样两个 interface：</p><p><img src="'+y+'" alt=""></p><p><img src="'+m+'" alt=""></p><p>在 controller、service、module 里分别实现它：</p><p><img src="'+u+'" alt=""></p><p><img src="'+_+'" alt=""></p><p><img src="'+F+'" alt=""></p><p>ddd 模块也是这样。</p><p>然后重新跑下服务，会看到这样的日志信息：</p><p><img src="'+C+'" alt=""></p><p>这就是 onModuleInit 和 onApplicationBootstrap 生命周期的调用顺序。</p><p>应用销毁的时候也同样有生命周期：</p><p><img src="'+B+'" alt=""></p><p>先调用每个模块的 controller、provider 的 onModuleDestroy 方法，然后调用 Module 的 onModuleDestroy 方法。</p><p>之后再调用每个模块的 controller、provider 的 beforeApplicationShutdown 方法，然后调用 Module 的 beforeApplicationShutdown 方法。</p><p>然后停止监听网络端口。</p><p>之后调用每个模块的 controller、provider 的 onApplicationShutdown 方法，然后调用 Module 的 onApplicationShutdown 方法。</p><p>之后停止进程。</p><p>是不是感觉 onModuleDestory 和 beforeApplicationShutdown 没区别呀？</p><p>其实是有区别的，可以看下对应的 interface：</p><p><img src="'+v+'" alt=""></p><p><img src="'+A+'" alt=""></p><p>beforeApplicationShutdown 是可以拿到 signal 系统信号的，比如 SIGTERM。</p><p>这些终止信号是别的进程传过来的，让它做一些销毁的事情，比如用 k8s 管理容器的时候，可以通过这个信号来通知它。</p><p>我们分别给 CccController、CccProvider、CccModule 还有 ddd 模块的那些给加一下：</p><p><img src="'+M+'" alt=""></p><p><img src="'+f+'" alt=""></p><p><img src="'+b+'" alt=""></p><p>3s 后调用 app.close() 触发销毁（app.close() 只是触发销毁逻辑，但不会真正退出进程）</p><p><img src="'+S+'" alt=""></p><p>生命周期方法是这样的执行顺序：</p><p><img src="'+D+'" alt=""></p><p>而且所有的生命周期函数都是支持 async 的。</p><p>我们来看看 @nestjs/typeorm、@nestjs/mongoose 里都是怎么用的：</p><p><img src="'+w+'" alt=""></p><p><img src="'+I+'" alt=""></p><p>可以看到，一般都是通过 moduleRef 取出一些 provider 来销毁，比如关闭连接。</p><p>这里的 moduleRef 就是当前模块的引用。</p><p>我们来试试：</p><p><img src="'+O+`" alt=""></p><p>onApplicationShutdown 的生命周期里，拿到当前模块的引用 moduleRef，调用 get 方法，传入 token，取出对应的 provider 实例，然后调用它的方法。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Module, OnModuleInit, OnApplicationBootstrap, OnModuleDestroy, BeforeApplicationShutdown, OnApplicationShutdown  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@nestjs/common&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { ModuleRef } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@nestjs/core&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { CccService } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./ccc.service&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { CccController } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./ccc.controller&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  controllers: [CccController],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  providers: [CccService]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CccModule</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> OnModuleInit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">OnApplicationBootstrap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">OnModuleDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">BeforeApplicationShutdown</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">OnApplicationShutdown</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  onModuleDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;CccModule onModuleDestroy&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  beforeApplicationShutdown</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">signal</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;CccModule beforeApplicationShutdown&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, signal);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  onApplicationShutdown</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cccService</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.moduleRef.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CccService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(CccService);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;--------------------------&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, cccService.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">findAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;CccModule onApplicationShutdown&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  onModuleInit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;CccModule OnModuleInit&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  onApplicationBootstrap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;CccModule onApplicationBootstrap&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><img src="`+P+'" alt=""></p><p>这就是 onApplicationShutdown 生命周期的常见用法。</p><p>案例代码在<a href="https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/global-and-lifecycle" target="_blank" rel="noreferrer">小册仓库</a>。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>这节我们学习了全局模块和生命周期。</p><p>模块可以通过 @Global 声明为全局的，这样它 exports 的 provider 就可以在各处使用了，不需要 imports。</p><p>provider、controller、module 都支持启动和销毁的生命周期函数，这些生命周期函数都支持 async 的方式。</p><p>可以在其中做一些初始化、销毁的逻辑，比如 onApplicationShutwon 里通过 moduleRef.get 取出一些 provider，执行关闭连接等销毁逻辑。</p><p>全局模块、生命周期、moduleRef 都是 Nest 很常用的功能。</p>',98),T=[N];function x(R,V,Q,J,U,G){return p(),i("div",null,T)}const L=s(j,[["render",x]]);export{Y as __pageData,L as default};
