import{_ as s,c as a,o as p,V as i}from"./chunks/framework.BbAbY5cn.js";const n="/assets/第62章-1.B8bK6ues.png",e="/assets/第62章-2.VallHKgs.png",t="/assets/第62章-3.5os_R_to.png",l="/assets/第62章-4.BA9MEpia.png",o="/assets/第62章-5.afY-RhOs.png",r="/assets/第62章-6.kDp7Zpc_.png",c="/assets/第62章-7._0mTNKwj.png",k="/assets/第62章-8.yYIjuVc5.png",h="/assets/第62章-9.FK1X9J-n.png",d="/assets/第62章-10.kgeHojU3.png",g="/assets/第62章-11.Ixr4FAcu.png",m="/assets/第62章-1.B8bK6ues.png",E="/assets/第62章-13.udb3jHDE.png",y="/assets/第62章-14.h2zA9rjd.png",_="/assets/第62章-15.rtSv9Z7a.png",u="/assets/第62章-16.tQ5fsoZ8.png",v="/assets/第62章-17.YpMV2qBT.png",b="/assets/第62章-18.wgkhkDvV.png",F="/assets/第62章-19.fXLGZ18y.png",w="/assets/第62章-20.127mvvIk.png",C="/assets/第62章-21.98Rx6xsr.png",D="/assets/第62章-22._sX23zHS.png",A="/assets/第62章-23.1ogjUqHP.png",q="/assets/第62章-24.A39d_fZ_.png",N="/assets/第62章-25.Jlzlx_o-.png",f="/assets/第62章-26.9AEzXIdJ.png",Z=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"第62章—Docker容器通信的最简单方式：桥接网络.md","filePath":"第62章—Docker容器通信的最简单方式：桥接网络.md"}'),B={name:"第62章—Docker容器通信的最简单方式：桥接网络.md"},x=i('<p>上节我们讲 Docker Compose 的时候，涉及到多个 docker 容器的通信，我们是通过指定宿主机 ip 和端口的方式。</p><p>因为 mysql、redis 的 Docker 容器都映射到了宿主机的端口，那 nest 的容器就可以通过宿主机来实现和其他容器的通信。</p><p><img src="'+n+'" alt=""></p><p>Docker 的实现原理那节我们讲过，Docker 通过 Namespace 的机制实现了容器的隔离，其中就包括 Network Namespace。</p><p>因为每个容器都有独立的 Network Namespace，所以不能直接通过端口访问其他容器的服务。</p><p>那如果这个 Network Namespace 不只包括一个 Docker 容器呢？？</p><p>可以创建一个 Network Namespace，然后设置到多个 Docker 容器，这样这些容器就在一个 Namespace 下了，不就可以直接访问对应端口了？</p><p>Docker 确实支持这种方式，叫做桥接网络。</p><p>通过 docker network 来创建：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>docker network create common-network</span></span></code></pre></div><p><img src="'+e+`" alt=""></p><p>然后把之前的 3 个容器停掉、删除，我们重新跑：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>docker stop mysql-container redis-container nest-container</span></span>
<span class="line"><span>docker rm mysql-container redis-container nest-container</span></span></code></pre></div><p><img src="`+t+'" alt=""></p><p>这次跑的时候要指定 --network：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>docker run -d --network common-network -v /Users/guang/mysql-data:/var/lib/mysql --name mysql-container mysql</span></span></code></pre></div><p>通过 --network 指定桥接网络为我们刚创建的 common-network。</p><p>不需要指定和宿主机的端口映射。</p><p><img src="'+l+'" alt="image.png"></p><p>然后跑 redis 容器：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>docker run -d --network common-network -v /Users/guang/aaa:/data --name redis-container redis</span></span></code></pre></div><p>同样也不需要指定和宿主机的端口映射，只需要指定挂载的数据卷就行：</p><p><img src="'+o+'" alt=""></p><p>然后 nest 的部分我们要改下代码：</p><p>修改 AppModule 的代码，改成用容器名来访问：</p><p><img src="'+r+'" alt=""></p><p>然后 docker build：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>docker build -t mmm .</span></span></code></pre></div><p><img src="'+c+'" alt=""></p><p>之后 docker run：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>docker run -d --network common-network -p 3000:3000 --name nest-container mmm</span></span></code></pre></div><p>nest 容器是要指定和宿主机的端口映射的，因为宿主机要访问这个端口的网页。</p><p><img src="'+k+'" alt=""></p><p>然后 docker logs 看下日志：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>docker logs nest-container</span></span></code></pre></div><p>可以看到打印了 sql 语句，说明 mysql 连接成功了：</p><p><img src="'+h+'" alt=""></p><p>浏览器访问 <a href="http://localhost:3000" target="_blank" rel="noreferrer">http://localhost:3000</a></p><p><img src="'+d+'" alt=""></p><p>然后再看下日志：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>docker logs nest-container</span></span></code></pre></div><p><img src="'+g+'" alt=""></p><p>打印了 redis 的 key 说明 redis 服务也连接成功了。</p><p>这就是桥接网络。</p><p>之前我们是通过宿主机 ip 来互相访问的：</p><p><img src="'+m+'" alt=""></p><p>现在可以通过容器名直接互相访问了：</p><p><img src="'+E+'" alt=""></p><p>原理前面讲过，就是 Namespace。</p><p>本来是 3 个独立的 Network Namespace：</p><p><img src="'+y+'" alt=""></p><p>桥接之后就这样了：</p><p><img src="'+_+'" alt=""></p><p>Namespace 下包含多个子 Namespace，互相能通过容器名访问。</p><p>比起端口映射到宿主机，再访问宿主机 ip 的方式，简便太多了。</p><p>那在 Docker Compose 里怎么使用这种方式呢？</p><p>之前我们是这样写的：</p><p><img src="'+u+`" alt=""></p><p>现在改成这样：</p><div class="language-yml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yml</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">version</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;3.8&#39;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">services</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  nest-app</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    build</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">./</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      dockerfile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">./Dockerfile</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    depends_on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      - </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">mysql-container</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      - </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">redis-container</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    ports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      - </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;3000:3000&#39;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    networks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      - </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">common-network</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  mysql-container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    image</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">mysql</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    volumes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      - </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/Users/guang/mysql-data:/var/lib/mysql</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    networks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      - </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">common-network</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  redis-container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    image</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">redis</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    volumes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      - </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/Users/guang/aaa:/data</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    networks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      - </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">common-network</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">networks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  common-network</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    driver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">bridge</span></span></code></pre></div><p>version 是指定 docker-compose.yml 的版本，因为不同版本配置不同。</p><p>把 mysql-container、redis-container 的 ports 映射去掉，指定桥接网络为 common-network。</p><p><img src="`+v+'" alt=""></p><p>然后下面通过 networks 指定创建的 common-network 桥接网络，网络驱动程序指定为 bridge。</p><p>其实我们一直用的网络驱动程序都是 bridge，它的含义是容器的网络和宿主机网络是隔离开的，但是可以做端口映射。比如 -p 3000:3000、-p 3306:3306 这样。</p><p>然后执行：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>docker-compose down --rmi all</span></span></code></pre></div><p>就会删除 3 个容器和它们的镜像：</p><p><img src="'+b+'" alt=""></p><p>之后再</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>docker-compose up</span></span></code></pre></div><p><img src="'+F+'" alt=""></p><p>可以看到，会先 build dockerfile 产生镜像，然后把 3 个镜像跑起来。</p><p><img src="'+w+'" alt=""></p><p>看到打印的 sql 说明 mysql 服务连接成功了。</p><p>（这个过程可能因为 mysql 容器没跑起来而连接失败几次，等一会就好了）</p><p>浏览器访问下：</p><p><img src="'+C+'" alt=""></p><p>也拿到了 redis 的 key，说明 redis 服务跑成功了：</p><p><img src="'+D+'" alt=""></p><p>这就是在 docker-compose 里使用桥接网络的方式。</p><p>不过，其实不指定 networks 也可以，docker-compose 会创建个默认的。</p><p>先把容器、镜像删掉：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>docker-compose down --rmi all</span></span></code></pre></div><p><img src="'+A+'" alt=""></p><p>把 networks 部分注释掉，重新跑：</p><p><img src="'+q+'" alt=""></p><p>你会发现它创建了一个默认的 network：</p><p><img src="'+N+'" alt=""></p><p>mysql 和 redis 的访问都是正常的：</p><p><img src="'+f+'" alt=""></p><p>所以，不手动指定 networks，也是可以用桥接网络的。</p><p>案例代码在<a href="https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/docker-compose-test" target="_blank" rel="noreferrer">小册仓库</a>。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>上节我们是把 mysql、redis 的端口映射到宿主机，然后 nest 的容器里通过宿主机 ip 访问这两个服务的。</p><p>但其实有更方便的方式，就是桥接网络。</p><p>通过 docker network create 创建一个桥接网络，然后 docker run 的时候指定 --network，这样 3 个容器就可以通过容器名互相访问了。</p><p>在 docker-compose.yml 配置下 networks 创建桥接网络，然后添加到不同的 service 上即可。</p><p>或者不配置 networkds，docker-compose 会生成一个默认的。</p><p>实现原理就是对 Network Namespace 的处理，本来是 3个独立的 Namespace，当指定了 network 桥接网络，就可以在 Namespace 下访问别的 Namespace 了。</p><p>多个容器之间的通信方式，用桥接网络是最简便的。</p>',101),T=[x];function V(j,P,S,I,U,H){return p(),a("div",null,T)}const z=s(B,[["render",V]]);export{Z as __pageData,z as default};
