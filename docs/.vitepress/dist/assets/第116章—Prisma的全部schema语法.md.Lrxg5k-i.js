import{_ as s,c as a,o as n,V as p}from"./chunks/framework.BbAbY5cn.js";const e="/assets/第116章-1.c75kMmGt.png",i="/assets/第116章-2.i4V-XrwD.png",t="/assets/第116章-3.PTCJlWCe.png",l="/assets/第116章-4.cvhkbN1z.png",c="/assets/第116章-5.piX5MAfk.png",o="/assets/第116章-6.npqwlCrN.png",r="/assets/第116章-7.Ue1S7KQR.png",d="/assets/第116章-8.-v9m1HRv.png",g="/assets/第116章-9.hwam9OUs.png",h="/assets/第116章-10.b-VqHG1v.png",m="/assets/第116章-11.TO32f_i_.png",u="/assets/第116章-12.wr2JWvA9.png",k="/assets/第116章-13.B8v0dX8s.png",v="/assets/第116章-14.9N9PEh_1.png",b="/assets/第116章-15.CoGZ-JdQ.png",_="/assets/第116章-16.DTA2c8lN.png",y="/assets/第116章-17.D72mZnWY.png",C="/assets/第116章-18.3hAo4aSU.png",E="/assets/第116章-19.Kmj9cP8S.png",q="/assets/第116章-20.0zMeV44W.png",F="/assets/第116章-21.FbHEKBiQ.png",f="/assets/第116章-22.GPVsrkkz.png",I="/assets/第116章-23.BXYssps6.png",T="/assets/第116章-24.ZJbnTnkL.png",x="/assets/第116章-25.sJRaYxwC.png",S="/assets/第116章-26.jcUpxVxJ.png",A="/assets/第116章-27.4lPJFAMy.png",B="/assets/第116章-28.oSg6nadL.png",D="/assets/第116章-29.vTjMHXtr.png",P="/assets/第116章-30.K3EmELTi.png",V="/assets/第116章-31.TenQUBwD.png",j="/assets/第116章-32.dkqUeG5I.png",w="/assets/第116章-33._r_s-bFi.png",R="/assets/第116章-34.0cDnHIII.png",U="/assets/第116章-35.QVG1RIt8.png",H="/assets/第116章-36.zMjx1KeP.png",J="/assets/第116章-37.pHYjNoEi.png",N="/assets/第116章-38.dTieev9z.png",G="/assets/第116章-39.-HKVOFw0.png",O="/assets/第116章-40.Lo6gNaVQ.png",K="/assets/第116章-41.sSF1TTif.png",Q="/assets/第116章-42.PgcBIu_y.png",L="/assets/第116章-43.mjWaie0b.png",M="/assets/第116章-44.fEFc6dv5.png",W="/assets/第116章-45.YgZF5yEE.png",z="/assets/第116章-46.Oj1Z74qG.png",X="/assets/第116章-47.V1DSsf1J.png",Y="/assets/第116章-48.o4woKP5W.png",os=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"第116章—Prisma的全部schema语法.md","filePath":"第116章—Prisma的全部schema语法.md"}'),Z={name:"第116章—Prisma的全部schema语法.md"},$=p(`<p>这节我们来学习下 Prisma 的 schema 文件的全部语法。</p><p>先创建个新项目：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>mkdir prisma-schema</span></span>
<span class="line"><span>cd prisma-schema</span></span>
<span class="line"><span>npm init -y</span></span></code></pre></div><p><img src="`+e+'" alt=""></p><p>全局安装 prisma：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>npm install -g prisma</span></span></code></pre></div><p>然后进入项目，执行 init 命令：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>prisma init</span></span></code></pre></div><p><img src="'+i+'" alt=""></p><p>生成了 .env 和 schema 文件：</p><p><img src="'+t+'" alt=""></p><p>然后改下 .env 文件的数据库连接信息：</p><p><img src="'+l+'" alt=""></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>DATABASE_URL=&quot;mysql://root:guang@localhost:3306/prisma_test&quot;</span></span></code></pre></div><p>改一下 db 的 provider 为 mysql，并且添加一个 model</p><p><img src="'+c+`" alt=""></p><div class="language-prisma vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">prisma</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">generator</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> client</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  provider </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;prisma-client-js&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">datasource</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> db</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  provider </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;mysql&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  url      </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> env</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;DATABASE_URL&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">model</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  id    </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     @id</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> @default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">autoincrement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  email </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  @unique</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name  </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>然后执行 generate 命令：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>prisma generate</span></span></code></pre></div><p>会在 node_modules/@prisma/client 下生成客户端代码：</p><p><img src="`+o+'" alt=""></p><p>这个生成位置是可以改的：</p><p><img src="'+r+`" alt=""> 在 generator 指定 output 的位置即可：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>generator client {</span></span>
<span class="line"><span>  provider = &quot;prisma-client-js&quot;</span></span>
<span class="line"><span>  output   = &quot;../generated/client&quot;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>然后再次 generate：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>prisma generate</span></span></code></pre></div><p>这时候就是在根目录生成的代码：</p><p><img src="`+d+'" alt=""></p><p><img src="'+g+'" alt=""></p><p>此外，generator 除了可以生成 client 代码外，还可以生成别的东西。</p><p>在<a href="https://www.prisma.io/docs/concepts/components/prisma-schema/generators#community-generators" target="_blank" rel="noreferrer">文档</a>里可以看到有很多社区的 generator：</p><p><img src="'+h+`" alt=""></p><p>我们试一下这个 json 和 docs 的 generator：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>npm install --save-dev prisma-docs-generator</span></span>
<span class="line"><span>npm install --save-dev prisma-json-schema-generator</span></span></code></pre></div><p>先安装相关的包。</p><p>然后在 schema 文件里配置 3 个 generator：</p><p><img src="`+m+`" alt=""></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>generator client {</span></span>
<span class="line"><span>  provider = &quot;prisma-client-js&quot;</span></span>
<span class="line"><span>  output   = &quot;../generated/client&quot;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>generator docs {</span></span>
<span class="line"><span>  provider = &quot;node node_modules/prisma-docs-generator&quot;</span></span>
<span class="line"><span>  output   = &quot;../generated/docs&quot;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>generator json {</span></span>
<span class="line"><span>  provider = &quot;prisma-json-schema-generator&quot;</span></span>
<span class="line"><span>  output   = &quot;../generated/json&quot;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>把 generated 目录删掉，重新生成：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>npx prisma generate</span></span></code></pre></div><p>注意，这里要用 npx 执行，因为如果是执行全局命令，会找不到项目目录下安装的 generator。</p><p><img src="`+u+'" alt=""></p><p>提示三个 generator 的产物都输出到了对应目录。</p><p><img src="'+k+'" alt=""></p><p>json schema 的 generator 会把 schema 文件转为 json 版：</p><p><img src="'+v+'" alt=""></p><p>而 docs 则是会生成文档。</p><p>我们跑起来看看：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>npx http-server ./generated/docs</span></span></code></pre></div><p><img src="'+b+'" alt=""></p><p>文档里会列出 model 的所有字段：</p><p><img src="'+_+'" alt=""></p><p>还有它的所有 CRUD 方法，每个方法的参数的类型等：</p><p><img src="'+y+'" alt=""></p><p>当你想做 crud 的时候，查下这个生成的文档，特别方便。</p><p>datasource 部分是配置数据库连接信息的。</p><p><img src="'+C+'" alt=""></p><p>provider 里指定连接的数据库的类型。</p><p>url 部分是连接的 url，也就是这个</p><p><img src="'+E+'" alt=""></p><p>在 schema 文件里可以用这种方式读取某个 env 的变量：</p><p><img src="'+q+`" alt=""></p><p>接下来是 model 部分。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>model User {</span></span>
<span class="line"><span>  id    Int     @id @default(autoincrement())</span></span>
<span class="line"><span>  email String  @unique</span></span>
<span class="line"><span>  name  String?</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>这部分很容易看懂，第一列是字段名，第二列是类型，第三列是一些其他信息。</p><p>首先重置一下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>prisma migrate reset</span></span></code></pre></div><p>我们用 migrate 命令生成 sql：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>prisma migrate dev --name aaa</span></span></code></pre></div><p><img src="`+F+'" alt=""></p><p>然后创建一个 aaa 的迁移：</p><p><img src="'+f+'" alt=""></p><p>它会创建对应的 sql 文件并执行：</p><p><img src="'+I+'" alt=""></p><p><img src="'+T+`" alt=""></p><p>可以看到 model 的声明和生成的 sql 的对应关系：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>model User {</span></span>
<span class="line"><span>  id    Int     @id @default(autoincrement())</span></span>
<span class="line"><span>  email String  @unique</span></span>
<span class="line"><span>  name  String?</span></span>
<span class="line"><span>}</span></span></code></pre></div><p><img src="`+x+'" alt=""></p><p>String 默认是 VARCHAR(191)</p><p>@id 会创建主键约束，@default 是默认值，而 autoincrement 是自增。</p><p>@unique 会创建唯一约束。</p><p><img src="'+S+'" alt=""></p><p>我们再创建一个 model</p><p><img src="'+A+`" alt=""></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>model Test {</span></span>
<span class="line"><span>  id Int @id @default(autoincrement())</span></span>
<span class="line"><span>  aaa String @db.Text</span></span>
<span class="line"><span>  bbb Int @db.TinyInt @map(&quot;bbb2&quot;)</span></span>
<span class="line"><span>  ccc String @db.VarChar(50) @unique</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  @@map(&quot;test_test&quot;)</span></span>
<span class="line"><span>  @@index([bbb, ccc])</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>这是 @db.xxx 可以指定具体的 mysql 的数据类型，有括号的是可以填入参数的，比如 VARCHAR 可以指定长度：</p><p><img src="`+B+'" alt=""></p><p><img src="'+D+'" alt=""></p><p>@map 是给字段指定另一个名字，@@map 是给表指定另一个名字。</p><p>而 @@index 则是创建一个索引，这里创建了 bbb、ccc 的联合索引。</p><p>索引就像书的目录一样，可以加快 sql 查询速度，sql 优化的时候我们经常会把高频查询的字段创建索引。</p><p>我们测试下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>npx prisma migrate dev --name bbb</span></span></code></pre></div><p>创建 bbb 的数据库迁移。</p><p><img src="'+P+'" alt=""> 生成的 sql 如下：</p><p><img src="'+V+`" alt=""></p><p>对比下 model 语法和生成的 sql：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>model Test {</span></span>
<span class="line"><span>  id Int @id @default(autoincrement())</span></span>
<span class="line"><span>  aaa String @db.Text</span></span>
<span class="line"><span>  bbb Int @db.TinyInt @map(&quot;bbb2&quot;)</span></span>
<span class="line"><span>  ccc String @db.VarChar(50) @unique</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  @@map(&quot;test_test&quot;)</span></span>
<span class="line"><span>  @@index([bbb, ccc])</span></span>
<span class="line"><span>}</span></span></code></pre></div><p><img src="`+j+'" alt=""></p><p>可以看到 @db.xxx、@map、@@map、@@index 都生效了</p><p>在 mysql workbench 里也可以看到这个表：</p><p><img src="'+w+'" alt=""></p><p>那表和表之间的一对多、多对多关系呢？</p><p>我们再添加几个 model：</p><p><img src="'+R+`" alt=""></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>model Department {</span></span>
<span class="line"><span>  id        Int    @id @default(autoincrement())</span></span>
<span class="line"><span>  name      String  @db.VarChar(20)</span></span>
<span class="line"><span>  createTime DateTime @default(now())</span></span>
<span class="line"><span>  updateTime DateTime @updatedAt</span></span>
<span class="line"><span>  employees     Employee[]</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>model Employee {</span></span>
<span class="line"><span>  id         Int       @id @default(autoincrement())</span></span>
<span class="line"><span>  name      String     @db.VarChar(20)</span></span>
<span class="line"><span>  phone     String     @db.VarChar(30)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  deaprtmentId Int</span></span>
<span class="line"><span>  department     Department      @relation(fields: [deaprtmentId], references: [id])</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>这里用到了几个新语法：</p><p>创建时间我们使用 @default(now()) 的方式指定，这样插入数据的时候会自动填入当前时间。</p><p>更新时间使用 @updatedAt，会自动设置当前时间。</p><p>员工和部门是多对一关系，在员工那一侧添加一个 departmentId 的列，然后通过 @relation 声明 deaprtmentId 的列引用 department 的 id 列。</p><p>测试下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>npx prisma migrate dev --name ccc</span></span></code></pre></div><p><img src="`+U+'" alt=""></p><p>可以看到，生成的 sql 是符合预期的：</p><p><img src="'+H+'" alt=""></p><p>并且在数据库里可以看到创建了对应的外键：</p><p><img src="'+J+'" alt=""></p><p>然后是多对多：</p><p><img src="'+N+`" alt=""></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>model Post {</span></span>
<span class="line"><span>  id        Int          @id @default(autoincrement())</span></span>
<span class="line"><span>  title     String</span></span>
<span class="line"><span>  content   String?</span></span>
<span class="line"><span>  published Boolean      @default(false)</span></span>
<span class="line"><span>  tags      TagOnPosts[]</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>model Tag {</span></span>
<span class="line"><span>  id    Int          @id @default(autoincrement())</span></span>
<span class="line"><span>  name  String</span></span>
<span class="line"><span>  posts TagOnPosts[]</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>model TagOnPosts {</span></span>
<span class="line"><span>  post   Post @relation(fields: [postId], references: [id])</span></span>
<span class="line"><span>  postId Int</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  tag    Tag @relation(fields: [tagId], references: [id])</span></span>
<span class="line"><span>  tagId  Int</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  @@id([postId, tagId])</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>有 sql 的基础很容易看懂，多对多需要创建一个中间表，中间表里有两个外键分别关联这两个表。</p><p>然后用 @@id 创建一个联合主键。</p><p>测试下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>npx prisma migrate dev --name ddd</span></span></code></pre></div><p><img src="`+G+'" alt=""></p><p>生成的 sql 如下：</p><p><img src="'+O+'" alt=""></p><p>中间表创建了 postId 和 tagId 的联合主键，并且创建了两个外键。</p><p>在 mysql 里可以看到这两个外键：</p><p><img src="'+K+'" alt=""></p><p>这就是一对多、多对多的映射方式。</p><p>至于一对一，那个就是在多的那一侧添加一个 unique 约束就好了：</p><p><img src="'+Q+'" alt=""></p><p>这样就把一对多变成了一对一。</p><p>此外，还有一个 enum 的语法，就是可以指定某个字段只能取一些枚举值：</p><p><img src="'+L+`" alt=""></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>model Aaa {</span></span>
<span class="line"><span>  id      Int      @id @default(autoincrement())</span></span>
<span class="line"><span>  name    String?</span></span>
<span class="line"><span>  role    EEE     @default(CCC)</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>enum EEE {</span></span>
<span class="line"><span>  BBB</span></span>
<span class="line"><span>  CCC</span></span>
<span class="line"><span>  DDD</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>创建迁移：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>npx prisma migrate dev --name eee</span></span></code></pre></div><p><img src="`+M+'" alt=""></p><p>生成的 sql 如下：</p><p><img src="'+W+'" alt=""></p><p>这个 enum 也是 sql 支持的语法（我们前面貌似没用过）。</p><p><img src="'+z+'" alt=""></p><p>这就是 prisma schema 的常用语法了，有一些不常用的没有列出来，大家遇去查<a href="https://www.prisma.io/docs/concepts/components/prisma-schema" target="_blank" rel="noreferrer">schema 文档</a>就好了。</p><p>最后，再看下生成的文档：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>npx http-server ./generated/docs</span></span></code></pre></div><p><img src="'+X+'" alt=""></p><p>每一个表的字段还有可用的 CRUD 方法都列出来了：</p><p><img src="'+Y+'" alt=""></p><p>确实很方便。</p><p>案例代码在<a href="https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/prisma-schema" target="_blank" rel="noreferrer">小册仓库</a></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>这节我们学习了 prisma schema 的常用语法。</p><p>generator 部分可以指定多种生成器，比如生成 json 生成 docs 等，可以指定生成代码的位置。</p><p>datasource 是配置数据库的类型和连接 url 的。</p><p>model 部分定义和数据库表的对应关系：</p><ul><li><strong>@id</strong> 定义主键</li><li><strong>@default</strong> 定义默认值</li><li><strong>@map</strong> 定义字段在数据库中的名字</li><li><strong>@db.xx</strong> 定义对应的具体类型</li><li><strong>@updatedAt</strong> 定义更新时间的列</li><li><strong>@unique</strong> 添加唯一约束</li><li><strong>@relation</strong> 定义外键引用</li><li><strong>@@map</strong> 定义表在数据库中的名字</li><li><strong>@@index</strong> 定义索引</li><li><strong>@@id</strong> 定义联合主键</li></ul><p>此外，还可以通过 enum 来创建枚举类型。</p><p>这些就是常用的 schema 语法了。</p>',160),ss=[$];function as(ns,ps,es,is,ts,ls){return n(),a("div",null,ss)}const rs=s(Z,[["render",as]]);export{os as __pageData,rs as default};
