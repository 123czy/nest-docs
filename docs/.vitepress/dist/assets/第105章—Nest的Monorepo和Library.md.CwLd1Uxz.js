import{_ as s,c as p,o as a,V as i}from"./chunks/framework.BbAbY5cn.js";const t="/assets/第105章-1.D0Wfaw7Q.png",n="/assets/第105章-2.3BV7q2pW.png",e="/assets/第105章-3.4YX_CWbj.png",l="/assets/第105章-4.0ALjVNKF.png",h="/assets/第105章-5.mqLri3hL.png",r="/assets/第105章-6.Ybeoipus.png",o="/assets/第105章-7.Gd6heBZ2.png",c="/assets/第105章-8.NVGOHUu0.png",k="/assets/第105章-9.jh6mUG83.png",g="/assets/第105章-10.DDj_ShXa.png",d="/assets/第105章-11.LPdS-RTM.png",E="/assets/第105章-12.IQiDfFie.png",m="/assets/第105章-13.W5lFtTrg.png",b="/assets/第105章-14.kJY4cBw1.png",u="/assets/第105章-15.fkIrKyRI.png",y="/assets/第105章-16.IzZiNAcq.png",_="/assets/第105章-17.pRGlse1L.png",v="/assets/第105章-18.gEZOaZx2.png",F="/assets/第105章-19.JzOrGplg.png",C="/assets/第105章-20.1103dm3t.png",B="/assets/第105章-21.V6gGWO8L.png",j="/assets/第105章-22.ScFIe8B3.png",x="/assets/第105章-23.c3s-zUda.png",f="/assets/第105章-24.dStLQTfv.png",L="/assets/第105章-25.sBz_lmdh.png",G="/assets/第105章-26.Ubt6R9pk.png",D="/assets/第105章-27.--TG9PDf.png",S="/assets/第105章-28.I9RW5rVG.png",A="/assets/第105章-29.ekp2gmGm.png",N="/assets/第105章-30.BSKfyj6z.png",V="/assets/第105章-31.VULJbBVK.png",T="/assets/第105章-32.KTD3wi4G.png",I="/assets/第105章-33.hoxZQr7o.png",q="/assets/第105章-34.rf4DJOLB.png",w="/assets/第105章-35.qtsihJDO.png",P="/assets/第105章-36.uLdKKiAq.png",K="/assets/第105章-37.q2CFVXUA.png",O="/assets/第105章-38._lG8vgFg.png",R="/assets/第105章-39.uyV6SZnG.png",ss=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"第105章—Nest的Monorepo和Library.md","filePath":"第105章—Nest的Monorepo和Library.md"}'),J={name:"第105章—Nest的Monorepo和Library.md"},M=i('<p>上节我们学习微服务时创建了 2 个 Nest 项目，如果微服务多了，可能会创建更多项目。</p><p>那问题来了，如果有 10 个微服务，我们就创建 10 个 Nest 项目的 git 仓库么？</p><p><img src="'+t+'" alt=""></p><p>那肯定不行，太难维护了。</p><p>这时候我们就需要 monorepo 了。</p><p><img src="'+n+'" alt=""></p><p>这样，同一个 git 仓库中存放多个 Nest 项目，外层叫做 workspace。</p><p>这样就算是 10 个微服务项目，也能在一个 Git 仓库里管理起来。</p><p>Nest 是支持这种 monorepo 的方式的，我们来试试看：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>nest new monorepo-test</span></span></code></pre></div><p>创建个 nest 项目</p><p><img src="'+e+'" alt=""></p><p>我们添加一个 aaa 的路由：</p><p><img src="'+l+`" alt=""></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;aaa&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aaa</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;aaa&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>改下端口：</p><p><img src="`+h+'" alt=""></p><p>然后把它跑起来：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>npm run start:dev</span></span></code></pre></div><p><img src="'+r+'" alt=""></p><p>浏览器访问下：</p><p><img src="'+o+'" alt=""></p><p>没啥问题。</p><p>然后我们再添加一个 nest 项目：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>nest g app app2</span></span></code></pre></div><p><img src="'+c+'" alt=""></p><p>它删除了 src 和 test，并创建了 apps 目录：</p><p><img src="'+k+'" alt=""></p><p>这里的 apps/monorepo-test 就是之前的 src、test 代码：</p><p><img src="'+g+'" alt=""></p><p>而 apps/app2 就是新创建的 nest 项目，或者叫 nest app。</p><p><img src="'+d+'" alt=""></p><p>把之前的服务停掉，重新跑:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>npm run start:dev</span></span></code></pre></div><p><img src="'+E+'" alt=""></p><p>可以看到，跑的还是之前的那个 nest 项目，只不过换成了 webpack 编译。</p><p><img src="'+m+'" alt=""></p><p>为什么同样都是 nest start --watch，换成 monorepo 的形式之后，还是跑之前项目呢？</p><p>答案在 nest-cli.json 里：</p><p>之前 nest-cli.json 是这样的：</p><p><img src="'+b+'" alt=""></p><p>现在变成了这样：</p><p><img src="'+u+'" alt=""></p><p>projects 下保存着多个 nest 项目的信息，比如根目录、入口文件、src 目录、编译配置文件。</p><p>然后 sourceRoot 和 root 分别指向了默认项目的 src 目录和根目录。</p><p>所以跑 nest start 的时候，才会依然跑的是之前的项目。</p><p>很明显，如果想跑另一个项目，就要这样：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>npm run start:dev app2</span></span></code></pre></div><p><img src="'+y+'" alt=""></p><p>比如我在 app2 添加一个 bbb 的路由：</p><p><img src="'+_+`" alt=""></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;bbb&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bbb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;bbb&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>浏览器访问下：</p><p><img src="`+v+'" alt=""></p><p>这样，app2 的服务就跑起来了。</p><p>原理也很简单，就是 nest cli 会根据 app 名字去读取对应的 tscofnig 文件：</p><p><img src="'+F+'" alt=""></p><p>这就是 nest 的 monorepo。</p><p>项目多了以后，难免有一些公共代码，这种公共代码怎么复用呢？</p><p>这就涉及到 nest 的另一个特性了：library。</p><p>创建一个 library：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>nest g lib lib1</span></span></code></pre></div><p><img src="'+C+'" alt=""></p><p>它会让你指定一个前缀，这里用默认的 @app。</p><p>然后会生成 libs/lib1 目录：</p><p><img src="'+B+'" alt=""></p><p>在 src 下生成了 module、service 并把它们导出了。</p><p>还在 tsconfig.json 的 paths 下添加了对应的别名配置：</p><p><img src="'+j+'" alt=""></p><p>在 nest-cli.json 里也多了这样一个 projects 配置：</p><p><img src="'+x+'" alt=""></p><p>我们在 LibService 添加一个 xxx 方法：</p><p><img src="'+f+`" alt=""></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">xxx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;xxx&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>然后在 monorepo-test 的 app 里导入 Lib1Module：</p><p><img src="`+L+'" alt=""></p><p>在 controller 里注入 Lib1Service 并调用它的方法：</p><p><img src="'+G+`" alt=""></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Inject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Lib1Service)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">private </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lib</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : Lib1Service;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;aaa&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aaa</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;aaa&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.lib.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">xxx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>同样的方式，在 app2 里也导入并使用它：</p><p><img src="`+D+'" alt=""></p><p><img src="'+S+`" alt=""></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Inject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Lib1Service)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">private </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lib</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : Lib1Service;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;bbb&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bbb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;bbb&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.lib.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">xxx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>然后分别把两个服务跑起来：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>npm run start:dev</span></span>
<span class="line"><span></span></span>
<span class="line"><span>npm run start:dev app2</span></span></code></pre></div><p><img src="`+A+'" alt=""></p><p><img src="'+N+'" alt=""></p><p>浏览器访问下 <a href="http://localhost:3001/aaa" target="_blank" rel="noreferrer">http://localhost:3001/aaa</a> 和 <a href="http://localhost:3000/bbb" target="_blank" rel="noreferrer">http://localhost:3000/bbb</a></p><p><img src="'+V+'" alt=""></p><p><img src="'+T+'" alt=""></p><p>可以看到，引入的 library 中的模块生效了。</p><p>如果你只是改 lib 下的代码，不想跑服务时，可以单独编译 lib 代码：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>npm run start:dev lib1</span></span></code></pre></div><p><img src="'+I+'" alt=""></p><p>nest 的 monorepo 和 libray 用起来都挺简单的。</p><p>还有个问题，现在 build 之后的代码是什么样的呢？</p><p>删掉 dist，然后执行：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>npm run build</span></span></code></pre></div><p>产生了一个 apps/monorepo-test/main.js，因为现在换成 webpack 了：</p><p><img src="'+q+'" alt=""></p><p>然后执行：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>npm run build app2</span></span></code></pre></div><p>现在就多了 apps/app2/main.js <img src="'+w+'" alt=""></p><p>lib1 也是同理：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>npm run build lib1</span></span></code></pre></div><p><img src="'+P+'" alt=""></p><p>之所以 application 或者 library 都能知道输出目录在哪，是因为在 tsconfig.json 里配了：</p><p><img src="'+K+'" alt=""></p><p><img src="'+O+'" alt=""></p><p><img src="'+R+'" alt=""></p><p>案例代码在<a href="https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/monorepo-test" target="_blank" rel="noreferrer">小册仓库</a></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>微服务项目可能会有很多个项目，为了方便管理，我们会使用 monorepo 的方式。</p><p>monorepo 就是在一个 git 仓库里管理多个项目。</p><p>nest cli 支持 monorepo，只要执行 nest g app xxx 就会把项目变为 monorepo 的，在 apps 下保存多个 nest 应用。</p><p>nest-cli.json 里配置了多个 projects 的信息，以及默认的 project。</p><p>npm run start:dev 或者 npm run build 可以加上应用名来编译对应的 app。</p><p>此外，多个项目可能有公共代码，这时候可以用 nest g lib xxx 创建 library。</p><p>library 保存在 libs 目录下，和 apps 一样可以有多个。</p><p>nest 会为 libs 创建别名，可以在其他 app 或者 lib 里用别名引入。</p><p>这就是 nest 里创建 monorepo 以及通过 library 复用代码的方式，用起来还是比较简单的。</p>',121),U=[M];function W(Z,z,Q,$,X,Y){return a(),p("div",null,U)}const ps=s(J,[["render",W]]);export{ss as __pageData,ps as default};
