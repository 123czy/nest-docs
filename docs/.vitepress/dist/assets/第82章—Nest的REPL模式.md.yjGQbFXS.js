import{_ as s,c as i,o as p,V as a}from"./chunks/framework.BbAbY5cn.js";const t="/assets/第82章-1.BCjj_Mps.png",n="/assets/第82章-2.hMWHf4Rv.png",e="/assets/第82章-3.wo6KowjV.png",l="/assets/第82章-4.NyW7IZHU.png",h="/assets/第82章-5.CrzNtger.png",r="/assets/第82章-6.bflVs1vA.png",k="/assets/第82章-7.VHNb1vZL.png",o="/assets/第82章-8.zHwI2tyb.png",c="/assets/第82章-9.kq2W_Bb9.png",d="/assets/第82章-10.fSgulFcw.png",g="/assets/第82章-11.vLfPqZ0q.png",E="/assets/第82章-12.AC_zx6FN.png",y="/assets/第82章-13.qulfqJFD.png",m="/assets/第82章-14.luZe0gBo.png",u="/assets/第82章-15.CPx8BUrp.png",v="/assets/第82章-16.Lri4z2Rc.png",F="/assets/第82章-17.DNEEilTe.png",_="/assets/第82章-18.dildqgc0.png",b="/assets/第82章-19.9cZljugV.png",C="/assets/第82章-20.4RYiGtOI.png",A="/assets/第82章-21.HJLsId5A.png",B="/assets/第82章-22.WjCZUTuu.png",D="/assets/第82章-23.8kEFIsF-.png",T=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"第82章—Nest的REPL模式.md","filePath":"第82章—Nest的REPL模式.md"}'),f={name:"第82章—Nest的REPL模式.md"},N=a('<p>我们写过很多 Module、Service、Controller，但这些都要服务跑起来之后在浏览器里访问对应的 url，通过 get 或者 post 的方式传参来测试。</p><p>这个还是挺麻烦的，能不能像 node 的 repl 那样，直接在控制台测试呢？</p><p>repl 是 read-eval-paint-loop，也就是这个：</p><p><img src="'+t+'" alt=""></p><p>Nest 能不能这样来测试呢？</p><p>可以的，Nest 支持 repl 模式。</p><p>我们创建个 Nest 项目：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>nest new repl-test</span></span></code></pre></div><p><img src="'+n+'" alt=""></p><p>然后创建两个模块：</p><p><img src="'+e+'" alt=""></p><p>把服务跑起来：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>npm run start:dev</span></span></code></pre></div><p><img src="'+l+'" alt=""></p><p>浏览器访问下：</p><p><img src="'+h+'" alt=""></p><p><img src="'+r+`" alt=""></p><p>我们前面都是这么测试接口的。</p><p>其实还可以用 repl 模式。</p><p>在 src 下创建个 repl.ts，写入如下内容：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { repl } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@nestjs/core&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { AppModule } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./app.module&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bootstrap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> repl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(AppModule);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bootstrap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>然后把服务停掉，通过这种方式跑：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>npm run start:dev -- --entryFile repl</span></span></code></pre></div><p>这里的 --entryFile 是指定入口文件是 repl.ts</p><p>前面带了个 -- 是指后面的参数不是传给 npm run start:dev 的，要原封不动保留。</p><p>也就是会传给 nest start</p><p><img src="`+k+'" alt=""></p><p>当然，你直接执行 nest start 也可以：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>nest start --watch --entryFile repl</span></span></code></pre></div><p>跑起来后，执行 debug()，会打印所有的 module 和 module 下的 controllers 和 providers。</p><p><img src="'+o+'" alt=""></p><p>而且，你可以 get() 来取对应的 providers 或者 controllers 调用：</p><p><img src="'+c+'" alt=""></p><p>get、post 方法都可以调用。</p><p>有的同学说，你这个 post 方法没有参数啊。</p><p>那我们加一些：</p><p><img src="'+d+'" alt=""></p><p>然后添加 ValidationPipe：</p><p><img src="'+g+`" alt=""></p><p>安装校验相关的包：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>npm install class-validator class-transformer</span></span></code></pre></div><p>在 dto 添加约束：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { IsEmail, IsNotEmpty } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;class-validator&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CreateAaaDto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IsNotEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    aaa</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IsEmail</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    bbb</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>我们先正常跑下服务：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>npm run start:dev</span></span></code></pre></div><p>然后 postman 里测试下：</p><p><img src="`+E+'" alt=""></p><p>可以看到，ValidationPipe 生效了。</p><p>那 repl 里是不是一样呢？</p><p>我们再跑下 repl 模式：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>npm run start:dev -- --entryFile repl</span></span></code></pre></div><p>可以看到，并没有触发 pipe：</p><p><img src="'+y+'" alt=""></p><p>也就是说，它只是单纯的传参调用这个函数，不会解析装饰器。</p><p>所以测试 controller 的话，repl 的方式是有一些限制的。</p><p>但是测试 service 很不错：</p><p><img src="'+m+'" alt=""></p><p>比如测试某个项目的 UserService 的 login 方法：</p><p><img src="'+u+'" alt=""></p><p>就很方便。</p><p>大概知道 repl 模式是做啥的之后，我们过一下常用的 api：</p><p>debug() 可以查看全部的 module 或者某个 module 下的 cotrollers、providers：</p><p><img src="'+v+'" alt=""></p><p><img src="'+F+'" alt=""></p><p>methods() 可以查看某个 controller 或者 provider 的方法：</p><p><img src="'+_+'" alt=""></p><p>get() 或者 $() 可以拿到某个 controller 或者 provider 调用它的方法：</p><p><img src="'+b+'" alt=""></p><p>常用的 api 就这些。</p><p>此外，按住上下键可以在历史命令中导航：</p><p><img src="'+C+`" alt=""></p><p>但有个问题。</p><p>当你重新跑之后，这些命令历史就消失了，再按上下键也没有历史。</p><p>可以改一下 repl.ts：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { repl } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@nestjs/core&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { AppModule } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./app.module&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bootstrap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> replServer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> repl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(AppModule);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    replServer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setupHistory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;.nestjs_repl_history&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (err) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(err);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bootstrap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>再跑的时候也是有历史的：</p><p><img src="`+A+'" alt=""></p><p>其实就是 nest 会把历史命令写入文件里，下一次跑就可以用它恢复历史了：</p><p><img src="'+B+'" alt=""></p><p>你还可以把这个命令配到 npm scripts 里：</p><p><img src="'+D+'" alt=""></p><p>然后直接 npm run repl:dev 来跑。</p><p>案例代码上传了<a href="https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/repl-login" target="_blank" rel="noreferrer">小册仓库</a>。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>这节我们学了 nest 的 repl 模式。</p><p>repl 模式下可以直接调用 controller 或者 provider 的方法，但是它们并不会触发 pipe、interceptor 等，只是传参测试函数。</p><p>可以使用 debug() 拿到 module、controller、provider 的信息，methods() 拿到方法，然后 get() 或者 $() 拿到 controller、provider 然后调用。</p><p>repl 模式对于测试 service 或者 contoller 的功能还是很有用的。</p>',88),j=[N];function P(q,I,S,V,w,L){return p(),i("div",null,j)}const x=s(f,[["render",P]]);export{T as __pageData,x as default};
