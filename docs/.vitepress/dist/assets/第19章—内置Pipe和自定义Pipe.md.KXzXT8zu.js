import{_ as p,c as s,o as t,V as e}from"./chunks/framework.BbAbY5cn.js";const a="/assets/第19章-1.01v5E1rD.png",r="/assets/第19章-2.6-3ClwX-.png",i="/assets/第19章-3.d3ZPTYc3.png",n="/assets/第19章-4.VTWI1udu.png",o="/assets/第19章-5.owW00I-A.png",c="/assets/第19章-6.Vpg1p-8Y.png",m="/assets/第19章-7.SrCPKwF8.png",_="/assets/第19章-8.m66mMJNZ.png",l="/assets/第19章-9.zmhM5EEZ.png",g="/assets/第19章-10.2gU1YAIJ.png",P="/assets/第19章-11.okwnmygk.png",d="/assets/第19章-12.6NgmTdx9.png",u="/assets/第19章-13.rPDyV7Uf.png",f="/assets/第19章-14.ymQkABwI.png",y="/assets/第19章-15.8T23gZir.png",h="/assets/第19章-16.9uD4Nr_D.png",U="/assets/第19章-17.sU5D5sRD.png",D="/assets/第19章-18.zz_0cTXQ.png",E="/assets/第19章-19.cdRyPmCE.png",B="/assets/第19章-20.EjqBPkXT.png",I="/assets/第19章-21._NB-LDJS.png",T="/assets/第19章-22.atHcf6u6.png",x="/assets/第19章-23.U_sksaCd.png",N="/assets/第19章-24.5oSAyw_q.png",V="/assets/第19章-25.8MXn9N22.png",v="/assets/第19章-26.Yg0QCOWj.png",k="/assets/第19章-27.1EZA1BBu.png",A="/assets/第19章-28.4ynxHQU6.png",F="/assets/第19章-29.9wzF80Or.png",S="/assets/第19章-30.GoGIStdr.png",w="/assets/第19章-31.aOtXpBvr.png",C="/assets/第19章-32.cg340g6Y.png",Q="/assets/第19章-33.-yGmuEem.png",Y="/assets/第19章-34.f7uueUte.png",b="/assets/第19章-35.6nvji2R-.png",z="/assets/第19章-36.mKzNWzHz.png",X="/assets/第19章-37.bNndMs3i.png",j="/assets/第19章-38.rybLE_mg.png",q="/assets/第19章-39.5GnP1Uoh.png",H="/assets/第19章-40.Wa6T6CkS.png",M="/assets/第19章-41.ME45BqNr.png",O="/assets/第19章-42.WyjNr1eY.png",W="/assets/第19章-43.EnX2BjeU.png",G="/assets/第19章-44.rTzY5fA8.png",Z="/assets/第19章-45.BajyfC2Q.png",J="/assets/第19章-46.mvkun3uH.png",R="/assets/第19章-47.dNVMNorL.png",$="/assets/第19章-48.QONsYYOt.png",cp=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"第19章—内置Pipe和自定义Pipe.md","filePath":"第19章—内置Pipe和自定义Pipe.md"}'),L={name:"第19章—内置Pipe和自定义Pipe.md"},K=e('<p>Pipe 是在参数传给 handler 之前对参数做一些验证和转换的 class，</p><p>对应的源码如下：</p><p><img src="'+a+'" alt=""></p><p>对每个参数都会应用 pipe：</p><p><img src="'+r+'" alt=""></p><p>内置的 Pipe 有这些：</p><ul><li>ValidationPipe</li><li>ParseIntPipe</li><li>ParseBoolPipe</li><li>ParseArrayPipe</li><li>ParseUUIDPipe</li><li>DefaultValuePipe</li><li>ParseEnumPipe</li><li>ParseFloatPipe</li><li>ParseFilePipe</li></ul><p>它们都实现了 PipeTransform 接口：</p><p>比如 ParseIntPipe 的源码是这样的：</p><p><img src="'+i+`" alt=""></p><p>我们分别来试下内置的 Pipe 的功能吧。</p><p>创建个项目：</p><pre><code>nest new pipe-test -p npm
</code></pre><p>参数默认是 string 类型：</p><p><img src="`+n+'" alt=""></p><p>我们可以通过 Pipe 把它转为整数：</p><p><img src="'+o+'" alt=""></p><p>效果如下：</p><p><img src="'+c+'" alt=""></p><p>当你传入的参数不能 parse 为 int 时，会返回这样的响应：</p><p><img src="'+m+'" alt=""></p><p>这个也是可以修改的，但要使用 new XxxPipe 的方式：</p><p><img src="'+_+'" alt=""></p><p>比如我指定错误时的状态码为 404。</p><p><img src="'+l+'" alt=""></p><p>就会返回这样的响应。</p><p>此外，你还可以自己抛一个异常出来，然后让 exception filter 处理：</p><p><img src="'+g+'" alt=""></p><p>可以看到，状态码和 message 都改了：</p><p><img src="'+P+'" alt=""></p><p>你也可以加个 @UseFilters 来使用自己的 exception filter 处理。</p><p>ParseFloatPipe 是把参数转换为 float 类型的。</p><p><img src="'+d+'" alt=""></p><p><img src="'+u+'" alt=""></p><p>它也同样可以 new ParseFloatPipe 的形式，传入 errorHttpStatusCode 和 exceptionFactory。</p><p>剩下这些与 parse 有关的 pipe 我们都试一下：</p><p>ParseBoolPipe：</p><p><img src="'+f+'" alt=""></p><p><img src="'+y+'" alt=""></p><p>ParseArrayPipe：</p><p><img src="'+h+'" alt=""></p><p>这时会提示需要 class-validator 这个包：</p><p><img src="'+U+'" alt=""></p><p>这是可以用装饰器和非装饰器两种方式对 class 属性做验证的库</p><p><img src="'+D+'" alt=""></p><p>还会提示需要 class-transformer 这个包：</p><p><img src="'+E+'" alt=""></p><p>它是把普通对象转换为对应的 class 实例的包：</p><p><img src="'+B+'" alt=""></p><p><img src="'+I+`" alt=""></p><p>后面我们也会用到这俩包。</p><p>安装这俩包：</p><pre><code>npm install -D class-validator class-transformer
</code></pre><p>然后访问下：</p><p><img src="`+T+'" alt=""></p><p>你会发现它确实把每一项都提取出来了，但是没有转为 number。</p><p>这时候就需要用 new XxxPipe 的方式传入参数了：</p><p><img src="'+x+'" alt=""></p><p>指定 item 的类型。</p><p>这样就把数组每一项处理为 number 了。</p><p><img src="'+N+'" alt=""></p><p>此外，你还可以指定分隔符：</p><p><img src="'+V+'" alt=""></p><p><img src="'+v+'" alt=""></p><p>当没有传参数的时候会报错：</p><p><img src="'+k+'" alt=""></p><p>可以把它设置为 optional：</p><p><img src="'+A+'" alt=""></p><p><img src="'+F+'" alt=""></p><p>然后是 ParseEnumPipe：</p><p>假设我们有这样一个枚举：</p><p><img src="'+S+'" alt=""></p><p>就可以用 ParseEnumPipe 来取：</p><p><img src="'+w+'" alt=""></p><p><img src="'+C+'" alt=""></p><p>有同学说，这不是多此一举么，本来 @Param 也能把它取出来呀。</p><p>ParseEnumPipe 还是有用的：</p><p>第一个是可以限制参数的取值范围：</p><p><img src="'+Q+'" alt=""></p><p>如果参数值不是枚举里的，就会报错。</p><p>这个错误自然也可以通过 errorHttpStatusCode 和 exceptionFactory 来定制。</p><p>第二个是帮你转换类型：</p><p><img src="'+Y+'" alt=""></p><p>这里拿到的就直接是枚举类型了，如果有个方法的参数是这样的枚举类型，就可以直接传入。</p><p>接下来是 ParseUUIDPipe：</p><p>UUID 是一种随机生成的几乎不可能重复的字符串，可以用来做 id。</p><p>它有 v3、v4、v5 3 个版本，我们用 uuid 包可以生成这种 id：</p><p><img src="'+b+'" alt=""></p><p>在参数里，可以用 ParseUUIDPipe 来校验是否是 UUID：</p><p><img src="'+z+'" alt=""></p><p>如果不是 uuid 会抛异常：</p><p><img src="'+X+'" alt=""></p><p><img src="'+j+'" alt=""></p><p>接下来是 DefaultValuePipe：</p><p>这个是设置参数默认值的：</p><p><img src="'+q+'" alt=""></p><p>当你没传参数的时候，会使用默认值：</p><p><img src="'+H+'" alt=""></p><p><img src="'+M+'" alt=""></p><p>它的源码也很简单：</p><p><img src="'+O+`" alt=""></p><p>还剩下 ValidationPipe 和 ParseFilePipe，这个我们之后再讲。</p><p>接下来我们自己实现个 Pipe 试一下：</p><pre><code>nest g pipe aaa --flat --no-spec
</code></pre><p>生成一个 pipe，打印下参数值，返回 aaa：</p><p><img src="`+W+'" alt=""></p><p>在 handler 里用下：</p><p><img src="'+G+'" alt=""></p><p>浏览器访问这个接口：</p><p><img src="'+Z+'" alt=""></p><p>返回的值是 aaaaaa，也就是说 pipe 的返回值就是传给 handler 的参数值。</p><p>打印的 value 就是 query、param 的值，而 metadata 里包含 type、metatype、data：</p><p><img src="'+J+'" alt=""></p><p>type 就是 @Query、@Param、@Body 装饰器，或者自定义装饰器：</p><p><img src="'+R+'" alt=""></p><p>而 metatype 是参数的 ts 类型：</p><p><img src="'+$+'" alt=""></p><p>data 是传给 @Query、@Param、@Body 等装饰器的参数。</p><p>有了这些东西，做一下验证，抛出异常给 exception filter 处理，或者对 value 做些转换再传给 handler 就都是很简单的事情了。</p><p>案例代码在<a href="https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/pipe-test" target="_blank" rel="noreferrer">小册仓库</a>。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>Pipe 是在参数传给 handler 之前做一些验证和转换的，有 9 个内置的 Pipe 可以直接用。</p><p>我们过了一遍内置的 ParseIntPipe、ParseBoolPipe、ParseArrayPipe、ParseUUIDPipe、ParseEnumPipe、ParseFloatPipe 还有 DefaultValuePipe。</p><p>剩下的 ValidationPipe 和 ParseFilePipe 之后的章节讲。</p><p>自己写一个 pipe 也很简单，就是实现 PipeTransform 接口的 transform 方法，它的返回值就是传给 handler 的值。</p><p>在 pipe 里可以拿到装饰器和 handler 参数的各种信息，基于这些来实现校验和转换就是很简单的事情了。</p>',126),pp=[K];function sp(tp,ep,ap,rp,ip,np){return t(),s("div",null,pp)}const mp=p(L,[["render",sp]]);export{cp as __pageData,mp as default};
