import{_ as p,c as s,o as t,V as e}from"./chunks/framework.BbAbY5cn.js";const r="/assets/第29章-1.ssTTX3mF.png",o="/assets/第29章-2.jHUYCBLb.png",a="/assets/第29章-3.HgfCp8h9.png",c="/assets/第29章-4.PmSeqUo9.png",n="/assets/第29章-5.HLlsDdqF.png",i="/assets/第29章-6.FXhkIPYI.png",_="/assets/第29章-7.Odohjr8F.png",m="/assets/第29章-8.bxIu81eL.png",l="/assets/第29章-9.TuVYAPei.png",g="/assets/第29章-10.LfpQeUKG.png",d="/assets/第29章-11.eEjWzFrz.png",k="/assets/第29章-12.S7r2gfR9.png",u="/assets/第29章-13.8wo9Jbus.png",h="/assets/第29章-14.i04FlaRQ.png",D="/assets/第29章-15.On6Jye3L.png",x="/assets/第29章-16.49CBmuAP.png",S="/assets/第29章-17.BBBC_d-a.png",f="/assets/第29章-18.uFlZ7nPg.png",v="/assets/第29章-19.I63R-9rS.png",T="/assets/第29章-20.veG9l6HS.png",b="/assets/第29章-21.CVW6gFxU.png",H="/assets/第29章-22.EeWuwwhI.png",P="/assets/第29章-23.SoSDHSLS.png",A="/assets/第29章-24.nSRTXMbr.png",F="/assets/第29章-25.jLpbCyT5.png",w="/assets/第29章-26.gsEuAzSZ.png",C="/assets/第29章-27.G558cJW3.png",V="/assets/第29章-28.QpjG8vdi.png",B="/assets/第29章-29.7Wm-_5Jv.png",E="/assets/第29章-30.e8UB5HpW.png",I="/assets/第29章-31.sIo8FvdE.png",L="/assets/第29章-32.CaVZ73m6.png",R="/assets/第29章-33.vN3kVZ0N.png",W="/assets/第29章-34.nd4WrHAc.png",y="/assets/第29章-35.m0GGOyFv.png",G="/assets/第29章-36.-3X4Tgel.png",U="/assets/第29章-37.0Cfc-HYx.png",Y="/assets/第29章-38.c7gZZ6Mi.png",Z="/assets/第29章-39.dDdYnRHS.png",pp=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"第29章—通过Desktop学Docker也太简单了.md","filePath":"第29章—通过Desktop学Docker也太简单了.md"}'),j={name:"第29章—通过Desktop学Docker也太简单了.md"},q=e('<p>后端系统会部署很多服务，包括我们自己开发的服务，还有 mysql、redis 等中间件的服务，部署它们需要一系列依赖的安装、环境变量的设置等等。</p><p>如果你要部署多台机器的话，同样的操作要重复多次，万一哪一步漏掉了，服务就跑不起来了。</p><p>就很麻烦。</p><p>而 Docker 就能完美解决这个问题：</p><p>它把系统的所有文件封装成一个镜像，镜像跑起来作为容器，它可以在一台机器上跑多个容器，每个容器都有独立的操作系统环境，比如文件系统、网络端口等，在容器内跑各种服务。</p><p>这样整个环境都保存在这个镜像里，部署多个实例只要通过这个镜像跑多个容器就行。</p><p><img src="'+r+'" alt=""></p><p>这也是为什么它的 logo 是这样的：</p><p><img src="'+o+'" alt=""></p><p>Docker 提供了 Docker Hub 镜像仓库，可以把本地镜像 push 到仓库或者从仓库 pull 镜像到本地。</p><p><img src="'+a+'" alt=""></p><p>我们 pull 个镜像下来试试看：</p><p>首先需要安装 Docker，直接从<a href="https://docker.com" target="_blank" rel="noreferrer">官网</a>下载 docker desktop 就行：</p><p>（windows 选择 widnows 的安装包。m1 要注意芯片类型，选择 apple chip 那个包）</p><p><img src="'+c+'" alt=""></p><p>它内置了 docker 命令。</p><p>把它安装到系统之后，可以在命令行看下 docker 命令是否可用：</p><p><img src="'+n+'" alt=""></p><p><img src="'+i+'" alt=""></p><p>如果不可用，那要设置下这个：</p><p><img src="'+_+'" alt=""></p><p>点击 Settings &gt; Advanced，里面有两种安装路径，如果是 /usr/local/bin，那 docker 命令就是直接可用的，因为这个路径在 PATH 变量里。</p><p>如果是第二种，那就需要手动把它加到 PATH 环境变量里。</p><p>然后我们来看看 docker desktop 的界面：</p><p><img src="'+m+'" alt=""></p><p><img src="'+l+'" alt=""></p><p>images 是本地的所有镜像，containers 是镜像跑起来的容器。</p><p>docker desktop 可以可视化的管理它们，很方便。</p><p>我们 pull 一个镜像试试看。</p><p><img src="'+g+'" alt=""></p><p>搜索 nginx 镜像，点击 pull（搜索这步需要翻墙，不然搜不到）。</p><p>pull 下来之后，就可以在本地 images 看到了：</p><p><img src="'+d+'" alt=""></p><p>点击 run 会让你填一些参数：</p><p><img src="'+k+'" alt=""></p><p>首先是名字，如果不填，docker desktop 会给你生成随机的容器名字。</p><p>就是这种：</p><p><img src="'+u+'" alt=""></p><p>然后是端口，容器内跑的 nginx 服务是在 80 端口，你要把宿主机的某个端口映射到容器的 80 端口才可以访问。</p><p>接下来是数据卷 volume，这个是把宿主机某个目录挂到容器内。</p><p>因为容器是镜像跑起来的，下次再用这个镜像跑的还是同样的容器，那你在容器内保存的数据就会消失。</p><p>所以我们都是把某个宿主机目录，挂载到容器内的某个保存数据的目录，这样数据是保存在宿主机的，下次再用镜像跑一个新容器，只要把这个目录挂载上去就行。</p><p>至于环境变量，这个就很容易理解了。</p><p>我们分别设置一下：</p><p><img src="'+h+'" alt=""></p><p>挂载本地的 /tmp/aaa 到容器内的 /usr/share/nginx/html 目录。</p><p>这里的 /tmp/aaa 可以换成宿主机的任何目录，如果是 windows 系统，那就是类似 D://tmp/aaa 这种。</p><p><strong>（注意，这里是 /usr 而不是 /user）</strong></p><p>点击 run：</p><p><img src="'+D+'" alt=""></p><p>可以看到容器内的 nginx 服务跑起来了。</p><p>我们在 /tmp/aaa 目录下添加一个 index.html:</p><p><img src="'+x+'" alt=""></p><p>浏览器访问 <a href="http://localhost" target="_blank" rel="noreferrer">http://localhost</a> 就可以访问到：</p><p><img src="'+S+'" alt=""></p><p>这就说明数据卷挂载成功了。</p><p>点击 files 标签就可以看到容器内的文件。</p><p>可以看到 /usr/share/nginx/html 被标识为 mounted，就是挂载目录的意思：</p><p><img src="'+f+'" alt=""></p><p>我们再在本地添加一个文件：</p><p><img src="'+v+'" alt=""></p><p>你会发现容器内这个目录内容也变了：</p><p><img src="'+T+'" alt=""></p><p>这就是 volume 挂载的作用。</p><p>如果你挂载某些目录报错，是因为 docker desktop 挂载的目录是需要配置的，在 Settings &gt; Resources &gt; File Sharing 里加一下就行：</p><p><img src="'+b+'" alt=""></p><p>至于挂载到的目录，在镜像搜索结果页有写：</p><p><img src="'+H+'" alt=""></p><p>通过命令行 docker run 来跑镜像， -v 是指定挂载的数据卷，后面的 :ro 代表 readonly，也就是容器内这个目录只读，:rw 表示容器内可以读写这个目录。</p><p>这就是数据卷的作用。</p><p>此外，你还可以进入到容器内执行各种命令：</p><p><img src="'+P+`" alt=""></p><p>是不是感觉 docker 学起来还挺简单的？</p><p>docker 常用的就是这些东西。</p><p>当然，在服务器上没有 Docker Desktop 这种东西，还是要敲命令的。</p><p>比如我们点击 pull 按钮，就相当于执行了 docker pull：</p><pre><code>docker pull nginx:latest
</code></pre><p>latest 是标签，也就是这个：</p><p><img src="`+A+`" alt=""></p><p>然后我们点击 run 按钮，填了个表单，就相当于执行了 docker run：</p><pre><code>docker run --name nginx-test2 -p 80:80 -v /tmp/aaa:/usr/share/nginx/html -e KEY1=VALUE1 -d nginx:latest 
</code></pre><p>-p 是端口映射</p><p>-v 是指定数据卷挂载目录</p><p>-e 是指定环境变量</p><p>-d 是后台运行</p><p>对照下前面可视化界面，是不是瞬间就懂了：</p><p><img src="`+F+'" alt=""></p><p>docker run 会返回一个容器的 hash：</p><p><img src="'+w+'" alt=""></p><p>就是这里的 id：</p><p><img src="'+C+'" alt=""></p><p>这个界面可以用 docker ps 来获取：</p><p><img src="'+V+'" alt=""></p><p>它是显示容器列表的，默认是运行中的。</p><p>想显示全部的，可以加个 -a</p><p><img src="'+B+'" alt=""></p><p>除了 container 列表，image 镜像列表也可以通过 docker images 命令获取：</p><p><img src="'+E+'" alt=""></p><p>我们在容器的 terminal 里执行命令，对应的是 docker exec 命令：</p><p><img src="'+I+'" alt=""></p><p><img src="'+L+'" alt=""></p><p>-i 是 terminal 交互的方式运行</p><p>-t 是 tty 终端类型</p><p>然后指定容器 id 和 shell 类型，就可以交互的方式在容器内执行命令了。</p><p>查看日志，对应 docker logs 命令：</p><p><img src="'+R+'" alt=""></p><p><img src="'+W+'" alt=""></p><p>输入 exit 退出：</p><p><img src="'+y+'" alt=""></p><p>docker inspect 可以查看容器的详情</p><p><img src="'+G+'" alt=""></p><p>对应 desktop 里的 inspect 的 tab：</p><p><img src="'+U+'" alt=""></p><p>docker volume 可以管理数据卷：</p><p><img src="'+Y+'" alt=""></p><p>对应 desktop 的这部分：</p><p><img src="'+Z+'" alt=""></p><p>此外，还有这些常用命令：</p><ul><li>docker start：启动一个已经停止的容器</li><li>docker rm：删除一个容器</li><li>docker stop：停止一个容器</li></ul><p>都可以通过 docker desktop 很方便的操作</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>Docker 可以把环境封装成镜像，镜像跑起来是一个独立的容器。通过这种方式可以快速部署多个相同的实例。</p><p>docker 提供了一个 desktop 工具，可以可视化的操作 docker，包括容器、镜像、volume 等</p><p>我们 pull 了一个 nginx 镜像下来，指定端口映射、挂载的数据卷，并把它跑起来了。</p><p>这就是 docker 的基本用法。</p><p>当然，这些可视化的操作都有对应的命令，当服务器上没有桌面的时候，就需要用命令行操作了。</p><p>不得不说，用 desktop 来学 docker 真是太简单了。</p>',127),J=[q];function N(O,X,$,z,Q,K){return t(),s("div",null,J)}const sp=p(j,[["render",N]]);export{pp as __pageData,sp as default};
