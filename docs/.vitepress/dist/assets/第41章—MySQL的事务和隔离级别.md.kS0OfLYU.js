import{_ as s,c as i,o as a,V as p}from"./chunks/framework.BbAbY5cn.js";const t="/assets/第41章-1.u7aC9MKx.png",n="/assets/第41章-2.Bj16YDs8.png",l="/assets/第41章-3.Xau6wSRk.png",h="/assets/第41章-4.hU9ItDvY.png",e="/assets/第41章-5.cxwou-Oj.png",k="/assets/第41章-6.foSuNAhp.png",r="/assets/第41章-7.IO6EpEPi.png",E="/assets/第41章-8.9WYiS7YB.png",g="/assets/第41章-9.iM55pdUL.png",d="/assets/第41章-10.c82Sf9tn.png",o="/assets/第41章-11.5Aga7pmY.png",c="/assets/第41章-12.3lhZ_U8I.png",y="/assets/第41章-13.QhvsxgQB.png",A="/assets/第41章-14.plBQQMD7.png",_="/assets/第41章-15.ZxjkN8_L.png",m="/assets/第41章-16.8_L_zuGM.png",B=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"第41章—MySQL的事务和隔离级别.md","filePath":"第41章—MySQL的事务和隔离级别.md"}'),u={name:"第41章—MySQL的事务和隔离级别.md"},F=p('<p>我们学习了增删改查的 sql 语句，并进行了大量的练习。</p><p>但有个问题：</p><p>如果是两个 update 的语句，一个把订单详情表数量修改了，一个把订单表的总金额修改了。但是改订单总金额的那个 sql 执行失败了。</p><p>这时候怎么办？</p><p>数量已经改了，但是总金额没改成功，就对不上了。</p><p>这种就需要事务（transaction）了。</p><p>它是这样用的：</p><p>比如 3 号订单的这三个商品，我们把它数量都改为 1。</p><p><img src="'+t+'" alt=""></p><p>那总金额就是 200，需要改 order 表的 total_amount 为 200。</p><p><img src="'+n+`" alt=""></p><p>我们先开启事务：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">START TRANSACTION</span></span></code></pre></div><p>然后执行两条 sql 语句：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">UPDATE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> order_items </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> quantity</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> order_id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">UPDATE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> orders </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> total_amount</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>分别修改了 order_items 的商品数量和 orders 的订单总金额。</p><p>然后再查询下现在 orders 表和 order_items 表的数据。</p><p><img src="`+l+'" alt=""></p><p><img src="'+h+'" alt=""></p><p>确实改了。</p><p>如果这时候你发现改错了，想再改回去，可你不记得之前的数据是啥了，怎么办呢？</p><p>别担心，这时候只要执行下 ROLLBACK 就好了。</p><p><img src="'+e+'" alt=""></p><p>你会发现它们的数据恢复了：</p><p><img src="'+k+'" alt=""></p><p><img src="'+r+`" alt=""></p><p>如果你确实想提交，那可以执行 COMMIT：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">START TRANSACTION</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">UPDATE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> order_items </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> quantity</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> order_id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">UPDATE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> orders </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> total_amount</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">COMMIT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>这时候数据就真正被修改，不能回滚了。</p><p><img src="`+E+`" alt=""></p><p>那如果我不是想回滚所有的 sql 语句，只是回滚一部分呢？</p><p>这需要手动告诉 mysql 一些保存的点：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">START TRANSACTION</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SAVEPOINT aaa;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">UPDATE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> order_items </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> quantity</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> order_id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SAVEPOINT bbb;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">UPDATE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> orders </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> total_amount</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SAVEPOINT ccc;</span></span></code></pre></div><p>比如我设置了 3 个保存点。</p><p>执行这段 sql，数据确实修改了：</p><p><img src="`+g+'" alt=""></p><p><img src="'+d+'" alt=""></p><p>这时候我们回滚到 bbb 的位置：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ROLLBACK</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> TO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SAVEPOINT bbb;</span></span></code></pre></div><p>然后再查询下：</p><p><img src="'+o+'" alt=""></p><p><img src="'+c+'" alt=""></p><p>这时候 order_items 表修改成功了，但是 orders 表修改没成功。</p><p>这确实是这个点的状态：</p><p><img src="'+y+'" alt="image.png"></p><p>再回滚到 ccc：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ROLLBACK</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> TO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SAVEPOINT ccc;</span></span></code></pre></div><p><img src="'+A+'" alt=""></p><p><img src="'+_+'" alt=""></p><p>这时候就都修改成功了。</p><p>这就是事务：</p><p><strong>START TRANSACTION 开启事务后所有的 sql 语句都可以 ROLLBACK，除非执行了 COMMIT 完成这段事务。</strong></p><p><strong>还可以设置几个 SAVEPOINT，这样可以 ROLLBACK TO 任何一个 SAVEPOINT 的位置。</strong></p><p>当你修改多个表的时候，并且这些表的数据是有关联的时候，事务是必须的。要不全部成功，要不全部不成功。</p><p>那如果事务还没有 COMMIT，但是它修改了一些表，这时候我们能查到它修改后的数据么？</p><p>这就涉及到事务的隔离级别的概念了。</p><p>MYSQL 有 4 种事务隔离级别：</p><ul><li><strong>READ UNCOMMITTED</strong>：可以读到别的事务尚未提交的数据。</li></ul><p>这就有个问题，你这个事务内第一次读的数据是 aaa，下次读可能就是 bbb 了，这个问题叫做<strong>不可重复读</strong>。</p><p>而且，万一你读到的数据人家又回滚了，那你读到的就是临时数据，这个问题叫做<strong>脏读</strong>。</p><ul><li><strong>READ COMMITTED</strong>：只读取别的事务已提交的数据。</li></ul><p>这样是没有脏读问题了，读到的不会是临时数据。</p><p>但是还是有可能你这个事务内第一次读的数据是 aaa，下次读可能是 bbb ，也就是不可重复读的问题依然存在。</p><p>不只是数据不一样，可能你两次读取到的记录行数也不一样，这叫做<strong>幻读</strong>。</p><ul><li><strong>REPEATABLE READ</strong>：在同一事务内，多次读取数据将保证结果相同。</li></ul><p>这个级别保证了读取到的数据一样，但是不保证行数一样，也就是说解决了不可重复读的问题，但仍然存在幻读的问题。</p><ul><li><strong>SERIALIZABLE</strong>：在同一时间只允许一个事务修改数据。</li></ul><p>事务一个个执行，各种问题都没有了。</p><p>但是负面影响就是性能很差，只能一个个的事务执行。</p><p>这 4 种级别主要是数据一致性和性能的差别，一致性越好，并发性能就越差。</p><p>需要根据实际情况来权衡。</p><p>可以这样查询当前的事务隔离级别：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @@transaction_isolation</span></span></code></pre></div><p><img src="'+m+'" alt=""></p><p>这个了解就好，一般用默认的。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>事务内的几条 sql 要么全部成功，要么全部不成功，这样能保证数据的一致性。</p><p>它的使用方式是 START TRANSACTION; COMMIT; 或者 ROLLBACK;</p><p>还可以设置 SAVEPOINT，然后 ROLLBACK TO SAVEPOINT;</p><p>事务还没提交的数据，别的事务能不能读取到，这就涉及到隔离级别的概念了。</p><p>一般就用默认的隔离级别就行，也就是 REPEATABLE READ。</p><p>基本上，只要写增删改的 sql，那都是要开事务的。</p>',82),T=[F];function C(D,b,S,v,O,R){return a(),i("div",null,T)}const I=s(u,[["render",C]]);export{B as __pageData,I as default};
